##################
Pulsar simulations
##################

You can use CWInPy to generate a simulated population of neutron star sources that can be used for
subsequent parameter estimation and hierarchical analyses. Currently, the simulation code assumes a
source signal model from a rigid triaxial rotator emitting from the :math:`l=m=2` quadrupole mode.
It is also assumes that the simulated population are known pulsars and therefore the data has been
:ref:`heterodyned <Heterodyned Data>` using a known phase evolution.

The simulation can either: generate a selection of entirely fake pulsars, with distributions
amplitude (defined through either the gravitational-wave strain amplitude :math:`h_0`, the mass
quadrupole :math:`Q_{22}`, or the ellipticity), source location (right ascension, declination and
distance) and pulsar orientation parameters supplied by the user (or set to defaults for everything
other than :math:`Q_{22}`); or, use supplied pulsars parameters and :ref:`heterodyned data
<Heterodyned Data>` into which to inject signals drawn from a population of :math:`Q_{22}`.

The simulations are generated using the :class:`~cwinpy.pe.simulation.PEPulsarSimulationDAG`
class which is described at the bottom of the page. Note that the simulation code described here
does not actually create the simulated gravitational-wave detector data. This is done in the
individual ``cwinpy_pe`` jobs generated by the script.

Simulation using fake data
==========================

As a first example we will create a simulation that generates a population of 1000 pulsars with
their :math:`Q_{22}` values drawn from an `exponential distribution
<https://en.wikipedia.org/wiki/Exponential_distribution>`_ with a mean of 10\ :sup:`33` kg m\
:sup:`2`\ , and sets up parameter estimation jobs for each. This population will be drawn from the
default distribution on the pulsar location (uniform over the sky and uniform within a distance
range between 0.1 and 10 kpc) and the default distribution on the pulsar orientation (uniform on the
hemisphere in inclination and polarisation angle and uniform in initial phase). We will set a prior
for the parameter estimation that has a uniform distribution in :math:`Q_{22}` between 0 and 10\
:sup:`40` kg m\ :sup:`2`\ .

.. code-block:: python

    >>> from cwinpy.pe.simulation import PEPulsarSimulationDAG
    >>> from bilby.core.prior import PriorDict, Uniform, Exponential, Sine
    >>> # set the Q22 distribution
    >>> mean = 1e33
    >>> ampdist = Exponential(name="q22", mu=mean)
    >>> # set the prior distribution for use in parameter estimation
    >>> prior = PriorDict({
    ...     "q22": Uniform(0.0, 1e40, name="q22"),
    ...     "iota": Sine(name="iota"),
    ...     "phi0": Uniform(0.0, np.pi, name="phi0"),
    ...     "psi": Uniform(0.0, np.pi / 2, name="psi"),
    ... })
    >>> # set the detectors to use (and generate fake data for)
    >>> detectors = ["H1", "L1"]
    >>> # generate the population
    >>> run = PEPulsarSimulationDAG(ampdist=ampdist, prior=prior, npulsars=1000, detector=detectors)

As no ``basedir`` argument was supplied this would produce the following directories and files in
your current working directory:

.. code-block:: console

    $ ls -p
    configs/  log/  priors/  pulsars/  results/ submit/

The ``pulsars`` directory will contain the 1000 pulsar parameter files with names based on their
generated right ascension and declination (clashing positions will have alphabetical identifiers
appended). The ``priors`` directory will contain 1000 prior files named after each pulsar. The
``configs`` directory will contain the 1000 ``cwinpy_pe`` :ref:`configuration files <Running the
analysis>`. The ``results`` directory will contain a directory for each pulsar into which the
outputs will be placed. The ``submit`` directory will contain the files required for running the
HTCondor DAG. There will be a Condor `submit
<https://htcondor.readthedocs.io/en/latest/man-pages/condor_submit.html#submit-description-file-commands>`_
files for each pulsar, which by default will be labelled ``cwinpy_pe_PSRNAME.submit`, where ``PSRNAME`` will be the pulsar name (note that names based on a positive declination will have ``+`` replaced with ``plus`` to make them allowable Condor job names)

We can take a look at the distribution of parameters that gets produced with:

.. code-block:: python

    >>> import corner
    >>> import glob
    >>> import numpy as np
    >>> from lalpulsar.PulsarParametersWrapper import PulsarParametersPy
    >>> params = np.zeros((1000, 8))
    >>> for i, parfile in enumerate(glob.glob("pulsars/*.par")):
    ...    psr = PulsarParametersPy(parfile)
    ...    params[i, :] = [psr["Q22"], psr["DIST"], psr["F0"], psr["RAJ"], psr["DECJ"], psr["IOTA"], psr["PHI0"], psr["PSI"]]
    >>> # make a corner plot of the distributions
    >>> labels = [r"$Q_{22}$ (kg m$^2$)", "distance (kpc)", r"$f_0$ (Hz)", r"$\alpha$ (rad)", r"$\delta$ (rad)", r"$\iota$ (rad)", r"$\phi_0$ (rad)", r"$\psi$ (rad)"]
    >>> fig = corner.corner(params, labels=labels, hist_kwargs={"density": True})
    >>> # overplot the Q22 distribution
    >>> ax = fig.get_axes()
    >>> lims = ax.get_xlim()
    >>> q22s = np.linspace(lims[0], lims[1], 100)
    >>> ax[0].plot(q22s, q22dist.prob(q22s))

.. thumbnail:: images/simulation_params.png
   :width: 600px
   :align: center

If you are on a machine, or computer cluster, with `HTCondor installed
<https://research.cs.wisc.edu/htcondor/downloads/>`_ these parameter estimation jobs can be run
using

.. code-block:: console

    $ condor_submit_dag cwinpy_pe_dag_DATETAG_01.submit

where ``DATETAG`` is a date string in the DAG file name based on the date you created it on.

You can perform an analysis using simulated data, but with real (or pre-defined) pulsar parameter
files. If you have a set of pulsar parameters files then these can be passed to the
:class:`~cwinpy.pe.simulation.PEPulsarSimulationDAG` class by giving a directory containing all the
files, or a dictionary of file paths keyed to the pulsar names. This takes the place of supplying a
number of pulsars to be simulated. For example, if we had parameter files in the directory
``my_pulsars`` this could be used with:

.. code-block:: python

    >>> pardir = "my_pulsars"
    >>> run = PEPulsarSimulationDAG(ampdist, prior=prior, parfiles=pardir, detector=detectors)

Note that you should not call the parameter file directory ``pulsars`` if it is in the same base
directory that you are generating the simulation in. That directory is reserved for pulsar parameter
files that contain the simulated population signal parameters for adding into the data.

Different distributions
-----------------------

You do not have to use the default distributions on the pulsar positions or orientation parameters.
If you had a model for a location distribution (and it can be put in the form of a bilby `prior
<https://lscsoft.docs.ligo.org/bilby/prior.html>`_) in `equatorial
<https://en.wikipedia.org/wiki/Equatorial_coordinate_system>`_ (right ascension and declination) or
`Galactic <https://en.wikipedia.org/wiki/Galactic_coordinate_system>`_ (galactic longitude and
latitude) coordinates and distance, or cartesian `Galactocentric
<https://docs.astropy.org/en/stable/api/astropy.coordinates.Galactocentric.html>`_ coordinates (in
kpc), then these can be used.

If using the equatorial system the prior dictionary must be keyed with ``"ra"``, ``"dec"`` and
``"dist"`` with angles in radians and distance in kpc. If using the Galactic coordinate system the
prior dictionary must be keyed with ``"l"``, ``"b"`` and ``"dist"``, again with angles in radians
and distance in kpc. For the Galactocentric system the prior dictionary must be keyed with ``"x"``,
``"y"`` and ``"z"`` in kpc.

For example, suppose we modelled the Galaxy as a thin Gaussian disk with a scale (standard deviation
of the Gaussian) of 9 kpc in the x-y plane, and 0.15 kpc in the z-direction, we could use this for
our pulsar population with:

.. code-block:: python

    >>> from bilby.core.prior import PriorDict, Gaussian
    >>> posdist = PriorDict({
    ...     "x": Gaussian(0.0, 9.0, name="x"),
    ...     "y": Gaussian(0.0, 9.0, name="y"),
    ...     "z": Gaussian(0.0, 0.15, name="z"),
    ... })
    >>> run = PEPulsarSimulationDAG(
    ...     ampdist, npulsars=1000, detector=detectors, posdist=posdist,
    ... )
    >>> # let's plot the sky distribution in RA and dec
    >>> from matplotlib import pyplot as pl
    >>> import glob
    >>> import numpy as np
    >>> from lalpulsar.PulsarParametersWrapper import PulsarParametersPy
    >>> params = np.zeros((1000, 2))
    >>> for i, parfile in enumerate(glob.glob("pulsars/*.par")): 
    ...     psr = PulsarParametersPy(parfile) 
    ...     params[i, :] = [-psr["RAJ"] if psr["RAJ"] < np.pi else -(psr["RAJ"] - 2 * np.pi), psr["DECJ"]]
    >>> fig, ax = pl.subplots(1, 1, subplot_kw={"projection": "mollweide"})
    >>> ax.scatter(params[:,0], params[:,1], s=8)
    >>> ax.set_xlabel("Right ascension")
    >>> ax.set_ylabel("Declination")
    >>> fig.savefig("mollweide.png", dpi=150, tight_layout=True)

.. thumbnail:: images/simulation_disk.png
   :width: 450px
   :align: center

If we wanted to fix a parameter like right ascension then we could use a Delta function prior in
that parameter, e.g.:

.. code-block:: python

    >>> from bilby.core.prior import PriorDict, DeltaFunction, Uniform, Cosine
    >>> posdist = PriorDict({
    ...     "ra": DeltaFunction(1.3, name="ra"),  # fix RA at 1.3 radians
    ...     "dec": Cosine(name="dec"),
    ...     "dist": Uniform(0.1, 10.0, name="dist"),
    ... })

The source orientation parameter distribution can also be set to something other than the default.
For example, to set the sources to all be linearly polarised you could use:

.. code-block:: python

    >>> from bilby.core.prior import PriorDict, DeltaFunction
    >>> oridist = PriorDict({
    ...     "iota": DeltaFunction(np.pi / 2., name="iota"),   
    ... })
    >>> run = PEPulsarSimulationDAG(
    ...     ampdist, npulsars=100, detector=detectors, oridist=oridist,
    ... )

In this case, as the other orientation parameters are not supplied they will automatically get set
to their default distributions.

Distance uncertainty
--------------------

Simulation using real data
==========================

Rather than the simulation running on simulated data and simulated pulsars it can be used to run on
a set of real data and use pre-defined or real pulsar parameter files.

.. autoclass:: cwinpy.pe.simulation.PEPulsarSimulationDAG
   :members: